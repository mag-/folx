# generated by fastapi-codegen:
#   filename:  api-specification.yml
#   timestamp: 2022-11-18T14:46:49+00:00

from __future__ import annotations

import datetime
import string
import time
import secrets
from typing import Any, Dict, List, Optional, Union
import uuid

from fastapi import Depends, FastAPI, Form, Header, HTTPException, Request, Response, status
from fastapi.responses import HTMLResponse
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jose import JWTError, jwt
from passlib.context import CryptContext
from pydantic import BaseModel
import pytz

from app.extensions import OAuth2PasswordBearerWithCookie
from app.services import (
    add_status,
    check_client_id_code,
    get_account,
    get_account_password,
    get_timeline,
    insert_account,
    save_oauth_client_data,
)
from starlette.responses import RedirectResponse

from .models import (
    Account,
    Activity,
    AdminAccount,
    AdminReport,
    Announcement,
    ApiV1AdminAccountsIdActionPostRequest,
    ApiV1AnnouncementsIdDismissPostResponse,
    ApiV1AnnouncementsIdReactionsNameDeleteResponse,
    ApiV1AnnouncementsIdReactionsNamePutResponse,
    ApiV1AppsPostRequest,
    ApiV1AppsPostResponse,
    ApiV1ConversationsIdDeleteResponse,
    ApiV1DomainBlocksDeleteResponse,
    ApiV1DomainBlocksPostResponse,
    ApiV1FeaturedTagsIdDeleteResponse,
    ApiV1FeaturedTagsPostRequest,
    ApiV1ListsDeleteResponse,
    ApiV1ListsIdAccountsDeleteResponse,
    ApiV1ListsIdAccountsPostRequest,
    ApiV1ListsIdAccountsPostResponse,
    ApiV1ListsPostRequest,
    ApiV1ListsPutRequest,
    ApiV1MarkersGetResponse,
    ApiV1MarkersPostRequest,
    ApiV1MarkersPostResponse,
    ApiV1NotificationsClearPostResponse,
    ApiV1PollsIdPostRequest,
    ApiV1PushSubscriptionDeleteResponse,
    ApiV1PushSubscriptionPostRequest,
    ApiV1PushSubscriptionPutRequest,
    ApiV1ReportsPostRequest,
    ApiV1ScheduledStatusesIdDeleteResponse,
    ApiV1ScheduledStatusesIdPutRequest,
    ApiV1StatusesIdReblogPostRequest,
    ApiV1StatusesPostRequest,
    ApiV1StatusesPostResponse,
    ApiV1SuggestionsIdDeleteResponse,
    ApiV2SearchGetResponse,
    Application,
    Attachment,
    Card,
    Context,
    Conversation,
    CreateAccountForm,
    Emoji,
    Error,
    FeaturedTag,
    Filter,
    IdentityProof,
    Instance,
    ListModel,
    Notification,
    OauthTokenPostRequest,
    OauthTokenPostResponse,
    Order1,
    Poll,
    Preferences,
    PushSubscription,
    Relationship,
    Report,
    ScheduledStatus,
    Source,
    Status,
    Tag,
    Type4,
)

SECRET_KEY = "ddc2fd9282902d323f90060499c5bb4e94e5284639c33e8f5dcaa9666f3c08f5"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW",
        "disabled": False,
    }
}
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


class Token(BaseModel):
    access_token: str
    token_type: str


class TokenData(BaseModel):
    username: str | None = None


class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


class UserInDB(User):
    hashed_password: str


def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password):
    return pwd_context.hash(password)


def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)


def authenticate_user(fake_db, username: str, password: str):
    user = get_user(fake_db, username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user


oauth2_scheme = OAuth2PasswordBearerWithCookie(tokenUrl="token")


def create_access_token(data: dict, expires_delta: datetime.timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.datetime.utcnow() + expires_delta
    else:
        expire = datetime.datetime.utcnow() + datetime.timedelta(days=30)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


async def get_current_user(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("acct")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except JWTError:
        raise credentials_exception
    user = get_account(token_data.username)
    if user is None:
        raise credentials_exception
    return user


app = FastAPI(
    title="Folx.co API Specification (https://github.com/mag-/folx)",
    version="0.0.1",
    contact={"name": "mag", "email": "mag@entropy.be"},
    servers=[{"url": "https://folx.co"}],
)

from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/api/oembed", response_model=Card, responses={"404": {"model": Error}})
def get_api_oembed(
    url: Optional[str] = None,
    maxwidth: Optional[int] = 400,
    maxheight: Optional[int] = None,
) -> Union[Card, Error]:
    pass


@app.get("/api/proofs", response_model=IdentityProof, responses={"404": {"model": Error}})
def get_api_proofs(provider: Optional[str] = None, username: Optional[str] = None) -> Union[IdentityProof, Error]:
    pass


@app.post("/api/v1/accounts", response_model=None)
def post_api_v1_accounts() -> None:
    pass


@app.get(
    "/api/v1/accounts/relationships",
    response_model=List[Relationship],
    responses={"401": {"model": Error}, "422": {"model": Error}},
)
def get_api_v1_accounts_relationships(
    id: List[str],
) -> Union[List[Relationship], Error]:
    pass


@app.get(
    "/api/v1/accounts/search",
    response_model=List[Account],
    responses={"503": {"model": Error}},
)
def get_api_v1_accounts_search(
    q: str,
    limit: Optional[int] = 40,
    resolve: Optional[str] = None,
    following: Optional[bool] = None,
) -> Union[List[Account], Error]:
    pass


@app.patch(
    "/api/v1/accounts/update_credentials",
    response_model=Account,
    responses={"401": {"model": Error}},
)
def patch_api_v1_accounts_update_credentials() -> Union[Account, Error]:
    pass


@app.get(
    "/api/v1/accounts/verify_credentials",
    response_model=Account,
    response_model_exclude_none=True,
    responses={"401": {"model": Error}, "403": {"model": Error}},
)
def get_api_v1_accounts_verify_credentials(current_user: Account = Depends(get_current_user)) -> Union[Account, Error]:
    if not current_user:
        return Error("The access token is invalid", status_code=401)
    if current_user.locked:
        return Error("Your login is currently disabled", status_code=403)
    return current_user


@app.get(
    "/api/v1/accounts/{id}",
    response_model=Account,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def get_api_v1_accounts_id(id: str) -> Union[Account, Error]:
    return get_account(id)


@app.post(
    "/api/v1/accounts/{id}/block",
    response_model=Relationship,
    responses={"401": {"model": Error}},
)
def post_api_v1_accounts_id_block(id: str) -> Union[Relationship, Error]:
    pass


@app.get(
    "/api/v1/accounts/{id}/featured_tags",
    response_model=List[FeaturedTag],
    responses={"401": {"model": Error}},
)
def get_api_v1_accounts_id_featured_tags(id: str) -> Union[List[FeaturedTag], Error]:
    pass


@app.post(
    "/api/v1/accounts/{id}/follow",
    response_model=Relationship,
    responses={"403": {"model": Error}},
)
def post_api_v1_accounts_id_follow(id: str) -> Union[Relationship, Error]:
    pass


@app.get(
    "/api/v1/accounts/{id}/followers",
    response_model=List[Account],
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def get_api_v1_accounts_id_followers(
    id: str,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
    limit: Optional[int] = 40,
) -> Union[List[Account], Error]:
    pass


@app.get(
    "/api/v1/accounts/{id}/following",
    response_model=List[Account],
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def get_api_v1_accounts_id_following(
    id: str,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
    limit: Optional[int] = 40,
) -> Union[List[Account], Error]:
    pass


@app.get(
    "/api/v1/accounts/{id}/identity_proofs",
    response_model=List[IdentityProof],
    responses={"404": {"model": Error}, "422": {"model": Error}},
)
def get_api_v1_accounts_id_identity_proofs(
    id: str,
) -> Union[List[IdentityProof], Error]:
    pass


@app.get(
    "/api/v1/accounts/{id}/lists",
    response_model=List[List],
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def get_api_v1_accounts_id_lists(id: str) -> Union[List[List], Error]:
    pass


@app.post(
    "/api/v1/accounts/{id}/mute",
    response_model=Relationship,
    responses={"401": {"model": Error}},
)
def post_api_v1_accounts_id_mute(id: str) -> Union[Relationship, Error]:
    pass


@app.post(
    "/api/v1/accounts/{id}/note",
    response_model=Relationship,
    responses={"401": {"model": Error}},
)
def post_api_v1_accounts_id_note(id: str) -> Union[Relationship, Error]:
    pass


@app.post(
    "/api/v1/accounts/{id}/pin",
    response_model=Relationship,
    responses={
        "401": {"model": Error},
        "403": {"model": Error},
        "422": {"model": Error},
        "500": {"model": Error},
    },
)
def post_api_v1_accounts_id_pin(id: str) -> Union[Relationship, Error]:
    pass


@app.get(
    "/api/v1/accounts/{id}/statuses",
    response_model=List[Status],
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def get_api_v1_accounts_id_statuses(id: str) -> Union[List[Status], Error]:
    return []


@app.post(
    "/api/v1/accounts/{id}/unblock",
    response_model=Relationship,
    responses={"401": {"model": Error}},
)
def post_api_v1_accounts_id_unblock(id: str) -> Union[Relationship, Error]:
    pass


@app.post(
    "/api/v1/accounts/{id}/unfollow",
    response_model=Relationship,
    responses={"401": {"model": Error}},
)
def post_api_v1_accounts_id_unfollow(id: str) -> Union[Relationship, Error]:
    pass


@app.post(
    "/api/v1/accounts/{id}/unmute",
    response_model=Relationship,
    responses={"401": {"model": Error}},
)
def post_api_v1_accounts_id_unmute(id: str) -> Union[Relationship, Error]:
    pass


@app.post(
    "/api/v1/accounts/{id}/unpin",
    response_model=Relationship,
    responses={"401": {"model": Error}},
)
def post_api_v1_accounts_id_unpin(id: str) -> Union[Relationship, Error]:
    pass


@app.get("/api/v1/admin/accounts", response_model=List[AdminAccount])
def get_api_v1_admin_accounts(
    local: Optional[bool] = None,
    remote: Optional[bool] = None,
    by_domain: Optional[str] = None,
    active: Optional[bool] = None,
    pending: Optional[bool] = None,
    disabled: Optional[bool] = None,
    silenced: Optional[bool] = None,
    suspended: Optional[bool] = None,
    staff: Optional[bool] = None,
    username: Optional[str] = None,
    display_name: Optional[str] = None,
    email: Optional[str] = None,
    ip: Optional[str] = None,
) -> List[AdminAccount]:
    pass


@app.get("/api/v1/admin/accounts/{id}", response_model=AdminAccount)
def get_api_v1_admin_accounts_id(id: str) -> AdminAccount:
    pass


@app.post("/api/v1/admin/accounts/{id}/action", response_model=None)
def post_api_v1_admin_accounts_id_action(id: str, body: ApiV1AdminAccountsIdActionPostRequest = None) -> None:
    pass


@app.post("/api/v1/admin/accounts/{id}/approve", response_model=None)
def post_api_v1_admin_accounts_id_approve(id: str) -> None:
    pass


@app.post("/api/v1/admin/accounts/{id}/enable", response_model=None)
def post_api_v1_admin_accounts_id_enable(id: str) -> None:
    pass


@app.post("/api/v1/admin/accounts/{id}/reject", response_model=None)
def post_api_v1_admin_accounts_id_reject(id: str) -> None:
    pass


@app.post("/api/v1/admin/accounts/{id}/unsilence", response_model=None)
def post_api_v1_admin_accounts_id_unsilence(id: str) -> None:
    pass


@app.post("/api/v1/admin/accounts/{id}/unsuspend", response_model=None)
def post_api_v1_admin_accounts_id_unsuspend(id: str) -> None:
    pass


@app.get("/api/v1/admin/reports", response_model=List[AdminReport])
def get_api_v1_admin_reports(
    resolved: Optional[bool] = None,
    account_id: Optional[str] = None,
    target_account_id: Optional[str] = None,
) -> List[AdminReport]:
    pass


@app.get("/api/v1/admin/reports/{id}", response_model=AdminReport)
def get_api_v1_admin_reports_id(id: str) -> AdminReport:
    pass


@app.post("/api/v1/admin/reports/{id}/assign_to_self", response_model=AdminReport)
def post_api_v1_admin_reports_id_assign_to_self(id: str) -> AdminReport:
    pass


@app.post("/api/v1/admin/reports/{id}/reopen", response_model=AdminReport)
def post_api_v1_admin_reports_id_reopen(id: str) -> AdminReport:
    pass


@app.post("/api/v1/admin/reports/{id}/resolve", response_model=AdminReport)
def post_api_v1_admin_reports_id_resolve(id: str) -> AdminReport:
    pass


@app.post("/api/v1/admin/reports/{id}/unassign", response_model=AdminReport)
def post_api_v1_admin_reports_id_unassign(id: str) -> AdminReport:
    pass


@app.get("/api/v1/announcements", response_model=List[Announcement])
def get_api_v1_announcements(
    with_dismissed: Optional[bool] = None,
) -> List[Announcement]:
    pass


@app.post(
    "/api/v1/announcements/{id}/dismiss",
    response_model=ApiV1AnnouncementsIdDismissPostResponse,
)
def post_api_v1_announcements_id_dismiss(
    id: str,
) -> ApiV1AnnouncementsIdDismissPostResponse:
    pass


@app.put(
    "/api/v1/announcements/{id}/reactions/{name}",
    response_model=ApiV1AnnouncementsIdReactionsNamePutResponse,
    responses={"422": {"model": Error}},
)
def put_api_v1_announcements_id_reactions_name(
    id: str, name: str = ...
) -> Union[ApiV1AnnouncementsIdReactionsNamePutResponse, Error]:
    pass


@app.delete(
    "/api/v1/announcements/{id}/reactions/{name}",
    response_model=ApiV1AnnouncementsIdReactionsNameDeleteResponse,
    responses={"422": {"model": Error}},
)
def delete_api_v1_announcements_id_reactions_name(
    id: str, name: str = ...
) -> Union[ApiV1AnnouncementsIdReactionsNameDeleteResponse, Error]:
    pass


@app.post(
    "/api/v1/apps",
    response_model=ApiV1AppsPostResponse,
    responses={"422": {"model": Error}},
)
async def post_api_v1_apps(req: Request) -> Union[ApiV1AppsPostResponse, Error]:
    if "application/json" in req.headers["content-type"]:
        r = ApiV1AppsPostRequest(**await req.json())
    else:
        r = ApiV1AppsPostRequest(**await req.form())
    print(f"{r.client_name=} {r.redirect_uris=} {r.scopes=} {r.website=}")
    # save client_id and secret in database

    resp = ApiV1AppsPostResponse()
    resp.id = "1"
    resp.name = r.client_name
    resp.website = r.website
    resp.redirect_uri = r.redirect_uris
    resp.client_id = "1"
    resp.client_secret = "1"
    resp.vapid_key = "1"
    if not resp.name:
        resp.name = "unknown"
    print(resp)
    return resp


@app.get(
    "/api/v1/apps/verify_credentials",
    response_model=Application,
    response_model_exclude_none=True,
    responses={"401": {"model": Error}},
)
def get_api_v1_apps_verify_credentials() -> Union[Application, Error]:
    pass


@app.get("/api/v1/blocks", response_model=List[Account], responses={"401": {"model": Error}})
def get_api_v1_blocks(
    limit: Optional[int] = None,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
) -> Union[List[Account], Error]:
    return []


@app.get(
    "/api/v1/bookmarks",
    response_model=List[Status],
    responses={"401": {"model": Error}},
)
def get_api_v1_bookmarks(
    limit: Optional[int] = None,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
    min_id: Optional[str] = None,
) -> Union[List[Status], Error]:
    pass


@app.get(
    "/api/v1/conversations",
    response_model=List[Conversation],
    responses={"401": {"model": Error}},
)
def get_api_v1_conversations(
    limit: Optional[int] = 20,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
    min_id: Optional[str] = None,
) -> Union[List[Conversation], Error]:
    pass


@app.delete(
    "/api/v1/conversations/{id}",
    response_model=ApiV1ConversationsIdDeleteResponse,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def delete_api_v1_conversations_id(
    id: str,
) -> Union[ApiV1ConversationsIdDeleteResponse, Error]:
    pass


@app.post(
    "/api/v1/conversations/{id}/read",
    response_model=Conversation,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def post_api_v1_conversations_id_read(id: str) -> Union[Conversation, Error]:
    pass


@app.get("/api/v1/custom_emojis", response_model=List[Emoji])
def get_api_v1_custom_emojis() -> List[Emoji]:
    return []


@app.get("/api/v1/directory", response_model=List[Account])
def get_api_v1_directory(
    limit: Optional[int] = 40,
    offset: Optional[int] = 0,
    order: Optional[Order1] = "active",
    local: Optional[bool] = None,
) -> List[Account]:
    pass


@app.get(
    "/api/v1/domain_blocks",
    response_model=List[str],
    responses={"401": {"model": Error}},
)
def get_api_v1_domain_blocks(
    limit: Optional[int] = None,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
) -> Union[List[str], Error]:
    pass


@app.post(
    "/api/v1/domain_blocks",
    response_model=ApiV1DomainBlocksPostResponse,
    responses={"401": {"model": Error}, "422": {"model": Error}},
)
def post_api_v1_domain_blocks() -> Union[ApiV1DomainBlocksPostResponse, Error]:
    pass


@app.delete(
    "/api/v1/domain_blocks",
    response_model=ApiV1DomainBlocksDeleteResponse,
    responses={"401": {"model": Error}, "422": {"model": Error}},
)
def delete_api_v1_domain_blocks(
    domain: str,
) -> Union[ApiV1DomainBlocksDeleteResponse, Error]:
    pass


@app.get(
    "/api/v1/endorsements",
    response_model=List[Account],
    responses={"401": {"model": Error}},
)
def get_api_v1_endorsements(
    limit: Optional[int] = 40,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
) -> Union[List[Account], Error]:
    pass


@app.get(
    "/api/v1/favourites",
    response_model=List[Status],
    responses={"401": {"model": Error}},
)
def get_api_v1_favourites(
    limit: Optional[str] = None,
    max_id: Optional[str] = None,
    min_id: Optional[str] = None,
) -> Union[List[Status], Error]:
    pass


@app.get(
    "/api/v1/featured_tags",
    response_model=List[FeaturedTag],
    responses={"401": {"model": Error}},
)
def get_api_v1_featured_tags() -> Union[List[FeaturedTag], Error]:
    pass


@app.post(
    "/api/v1/featured_tags",
    response_model=FeaturedTag,
    responses={"422": {"model": Error}},
)
def post_api_v1_featured_tags(
    body: ApiV1FeaturedTagsPostRequest = None,
) -> Union[FeaturedTag, Error]:
    pass


@app.get(
    "/api/v1/featured_tags/suggestions",
    response_model=List[FeaturedTag],
    responses={"401": {"model": Error}},
)
def get_api_v1_featured_tags_suggestions() -> Union[List[FeaturedTag], Error]:
    pass


@app.delete(
    "/api/v1/featured_tags/{id}",
    response_model=ApiV1FeaturedTagsIdDeleteResponse,
    responses={"404": {"model": Error}},
)
def delete_api_v1_featured_tags_id(
    id: str,
) -> Union[ApiV1FeaturedTagsIdDeleteResponse, Error]:
    pass


@app.get("/api/v1/filters", response_model=List[Filter], responses={"401": {"model": Error}})
def get_api_v1_filters() -> Union[List[Filter], Error]:
    return []


@app.post(
    "/api/v1/filters",
    response_model=Filter,
    responses={"401": {"model": Error}, "422": {"model": Error}},
)
def post_api_v1_filters() -> Union[Filter, Error]:
    pass


@app.get(
    "/api/v1/filters/{id}",
    response_model=Filter,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def get_api_v1_filters_id(id: str) -> Union[Filter, Error]:
    pass


@app.put(
    "/api/v1/filters/{id}",
    response_model=Filter,
    responses={
        "401": {"model": Error},
        "404": {"model": Error},
        "422": {"model": Error},
    },
)
def put_api_v1_filters_id(id: str) -> Union[Filter, Error]:
    pass


@app.delete(
    "/api/v1/filters/{id}",
    response_model=None,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def delete_api_v1_filters_id(id: str) -> Union[None, Error]:
    pass


@app.get(
    "/api/v1/follow_requests",
    response_model=List[Account],
    responses={"401": {"model": Error}},
)
def get_api_v1_follow_requests(
    limit: Optional[int] = 40,
) -> Union[List[Account], Error]:
    pass


@app.post(
    "/api/v1/follow_requests/{id}/authorize",
    response_model=Relationship,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def post_api_v1_follow_requests_id_authorize(id: str) -> Union[Relationship, Error]:
    pass


@app.post(
    "/api/v1/follow_requests/{id}/reject",
    response_model=Relationship,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def post_api_v1_follow_requests_id_reject(id: str) -> Union[Relationship, Error]:
    pass


@app.get("/api/v1/instance", response_model=Instance)
def get_api_v1_instance() -> Instance:
    i = Instance(
        uri="https://folx.co/",
        title="Folx",
        description="Folx is a social network for people who want to be heard.",
        short_description="Folx",
        email="hello@folx.co",
        version="0.0.1folx",
        languages=["en"],
        thumbnail="https://folx.co/assets/images/logo.png",
        registrations=True,
        approval_required=False,
        invites_enabled=True,
        urls={"streaming_api": "wss://folx.co"},
        stats={"user_count": 10000000000, "status_count": 1000000000, "domain_count": 1000000000},
    )
    return i


@app.get("/api/v1/instance/activity", response_model=List[Activity])
def get_api_v1_instance_activity() -> List[Activity]:
    pass


@app.get("/api/v1/instance/peers", response_model=List[str])
def get_api_v1_instance_peers() -> List[str]:
    pass


@app.get("/api/v1/lists", response_model=List[List], responses={"401": {"model": Error}})
def get_api_v1_lists() -> Union[List[List], Error]:
    pass


@app.post("/api/v1/lists", response_model=List, responses={"401": {"model": Error}})
def post_api_v1_lists(body: ApiV1ListsPostRequest = None) -> Union[List, Error]:
    pass


@app.put(
    "/api/v1/lists",
    response_model=List,
    responses={"401": {"model": Error}, "422": {"model": Error}},
)
def put_api_v1_lists(body: ApiV1ListsPutRequest = None) -> Union[List, Error]:
    pass


@app.delete(
    "/api/v1/lists",
    response_model=ApiV1ListsDeleteResponse,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def delete_api_v1_lists() -> Union[ApiV1ListsDeleteResponse, Error]:
    pass


@app.get(
    "/api/v1/lists/{id}",
    response_model=List,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def get_api_v1_lists_id(id: str) -> Union[List, Error]:
    pass


@app.get(
    "/api/v1/lists/{id}/accounts",
    response_model=List[Account],
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def get_api_v1_lists_id_accounts(
    id: str,
    limit: Optional[int] = 40,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
) -> Union[List[Account], Error]:
    pass


@app.post(
    "/api/v1/lists/{id}/accounts",
    response_model=ApiV1ListsIdAccountsPostResponse,
    responses={
        "401": {"model": Error},
        "404": {"model": Error},
        "422": {"model": Error},
    },
)
def post_api_v1_lists_id_accounts(
    id: str, body: ApiV1ListsIdAccountsPostRequest = None
) -> Union[ApiV1ListsIdAccountsPostResponse, Error]:
    pass


@app.delete(
    "/api/v1/lists/{id}/accounts",
    response_model=ApiV1ListsIdAccountsDeleteResponse,
    responses={
        "401": {"model": Error},
        "404": {"model": Error},
        "422": {"model": Error},
    },
)
def delete_api_v1_lists_id_accounts(
    account_ids: List[str], id: str = ...
) -> Union[ApiV1ListsIdAccountsDeleteResponse, Error]:
    pass


@app.get(
    "/api/v1/markers",
    response_model=ApiV1MarkersGetResponse,
    responses={"401": {"model": Error}},
)
def get_api_v1_markers(timeline: List[Dict[str, Any]]) -> Union[ApiV1MarkersGetResponse, Error]:
    pass


@app.post(
    "/api/v1/markers",
    response_model=ApiV1MarkersPostResponse,
    responses={"401": {"model": Error}, "409": {"model": Error}},
)
def post_api_v1_markers(
    body: ApiV1MarkersPostRequest = None,
) -> Union[ApiV1MarkersPostResponse, Error]:
    pass


@app.post(
    "/api/v1/media",
    response_model=Attachment,
    responses={"401": {"model": Error}, "422": {"model": Error}},
)
def post_api_v1_media() -> Union[Attachment, Error]:
    pass


@app.get(
    "/api/v1/media/{id}",
    response_model=Attachment,
    responses={
        "206": {"model": Attachment},
        "401": {"model": Error},
        "404": {"model": Error},
        "422": {"model": Error},
    },
)
def get_api_v1_media_id(id: str) -> Union[Attachment, Error]:
    pass


@app.post(
    "/api/v1/media/{id}",
    response_model=Attachment,
    responses={
        "401": {"model": Error},
        "404": {"model": Error},
        "422": {"model": Error},
    },
)
def post_api_v1_media_id(id: str) -> Union[Attachment, Error]:
    pass


@app.get("/api/v1/mutes", response_model=List[Account], responses={"401": {"model": Error}})
def get_api_v1_mutes(
    limit: Optional[str] = None,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
) -> Union[List[Account], Error]:
    return []


@app.get(
    "/api/v1/notifications",
    response_model=List[Notification],
    responses={"401": {"model": Error}},
)
def get_api_v1_notifications(
    limit: Optional[int] = 20,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
    min_id: Optional[str] = None,
    exclude_types: Optional[List[str]] = None,
    account_id: Optional[str] = None,
) -> Union[List[Notification], Error]:
    pass


@app.post(
    "/api/v1/notifications/clear",
    response_model=ApiV1NotificationsClearPostResponse,
    responses={"401": {"model": Error}},
)
def post_api_v1_notifications_clear() -> Union[ApiV1NotificationsClearPostResponse, Error]:
    pass


@app.get(
    "/api/v1/notifications/{id}",
    response_model=Notification,
    responses={"401": {"model": Error}},
)
def get_api_v1_notifications_id(id: str) -> Union[Notification, Error]:
    pass


@app.post(
    "/api/v1/notifications/{id}/dismiss",
    response_model=Notification,
    responses={"401": {"model": Error}},
)
def post_api_v1_notifications_id_dismiss(id: str) -> Union[Notification, Error]:
    pass


@app.get("/api/v1/polls/{id}", response_model=Poll, responses={"404": {"model": Error}})
def get_api_v1_polls_id(id: str) -> Union[Poll, Error]:
    pass


@app.post(
    "/api/v1/polls/{id}",
    response_model=Poll,
    responses={
        "401": {"model": Error},
        "404": {"model": Error},
        "422": {"model": Error},
    },
)
def post_api_v1_polls_id(id: str, body: ApiV1PollsIdPostRequest = None) -> Union[Poll, Error]:
    pass


@app.get(
    "/api/v1/preferences",
    response_model=Preferences,
    responses={"401": {"model": Error}},
)
def get_api_v1_preferences() -> Union[Preferences, Error]:
    pass


@app.post(
    "/api/v1/push/subscription",
    response_model=PushSubscription,
    responses={"401": {"model": Error}},
)
def post_api_v1_push_subscription(
    body: ApiV1PushSubscriptionPostRequest = None,
) -> Union[PushSubscription, Error]:
    pass


@app.get(
    "/api/v1/push/subscription",
    response_model=PushSubscription,
    responses={"404": {"model": Error}},
)
def get_api_v1_push_subscription() -> Union[PushSubscription, Error]:
    pass


@app.put(
    "/api/v1/push/subscription",
    response_model=PushSubscription,
    responses={"404": {"model": Error}},
)
def put_api_v1_push_subscription(
    body: ApiV1PushSubscriptionPutRequest = None,
) -> Union[PushSubscription, Error]:
    pass


@app.delete("/api/v1/push/subscription", response_model=ApiV1PushSubscriptionDeleteResponse)
def delete_api_v1_push_subscription() -> ApiV1PushSubscriptionDeleteResponse:
    pass


@app.post("/api/v1/reports", response_model=Report, responses={"401": {"model": Error}})
def post_api_v1_reports(body: ApiV1ReportsPostRequest = None) -> Union[Report, Error]:
    pass


@app.get(
    "/api/v1/scheduled_statuses",
    response_model=List[ScheduledStatus],
    responses={"401": {"model": Error}},
)
def get_api_v1_scheduled_statuses(
    limit: Optional[int] = 20,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
    min_id: Optional[str] = None,
) -> Union[List[ScheduledStatus], Error]:
    pass


@app.get(
    "/api/v1/scheduled_statuses/{id}",
    response_model=ScheduledStatus,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def get_api_v1_scheduled_statuses_id(id: str) -> Union[ScheduledStatus, Error]:
    pass


@app.put(
    "/api/v1/scheduled_statuses/{id}",
    response_model=ScheduledStatus,
    responses={
        "401": {"model": Error},
        "404": {"model": Error},
        "422": {"model": Error},
    },
)
def put_api_v1_scheduled_statuses_id(
    id: str, body: ApiV1ScheduledStatusesIdPutRequest = None
) -> Union[ScheduledStatus, Error]:
    pass


@app.delete(
    "/api/v1/scheduled_statuses/{id}",
    response_model=ApiV1ScheduledStatusesIdDeleteResponse,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def delete_api_v1_scheduled_statuses_id(
    id: str,
) -> Union[ApiV1ScheduledStatusesIdDeleteResponse, Error]:
    pass


@app.post(
    "/api/v1/statuses",
    response_model=ApiV1StatusesPostResponse,
    response_model_exclude_none=True,
    responses={"401": {"model": Error}},
)
async def post_api_v1_statuses(
    idempotency__key: Optional[str] = Header(None, alias="Idempotency-Key"),
    req: Request = None,
    current_user: Account = Depends(get_current_user),
) -> Union[ApiV1StatusesPostResponse, Error]:
    if req.headers["Content-Type"] == "application/json":
        r = ApiV1StatusesPostRequest(**await req.json())
    else:
        r = ApiV1StatusesPostRequest(**await req.form())
    s = Status(
        content=r.status,
        language=r.language,
        account=current_user,
        visibility="public",
        sensitive=False,
        media_attachments=[],
        mentions=[],
        tags=[],
        emojis=[],
        spoiler_text="r.spoiler_text",
    )
    s = add_status(current_user.acct, s)
    print(s)
    return s


@app.get(
    "/api/v1/statuses/{id}",
    response_model=Status,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def get_api_v1_statuses_id(id: str) -> Union[Status, Error]:
    pass


@app.delete(
    "/api/v1/statuses/{id}",
    response_model=Status,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def delete_api_v1_statuses_id(id: str) -> Union[Status, Error]:
    pass


@app.post(
    "/api/v1/statuses/{id}/bookmark",
    response_model=Status,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def post_api_v1_statuses_id_bookmark(id: str) -> Union[Status, Error]:
    pass


@app.get(
    "/api/v1/statuses/{id}/context",
    response_model=Context,
    responses={"404": {"model": Error}},
)
def get_api_v1_statuses_id_context(id: str) -> Union[Context, Error]:
    pass


@app.post(
    "/api/v1/statuses/{id}/favourite",
    response_model=Status,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def post_api_v1_statuses_id_favourite(id: str) -> Union[Status, Error]:
    pass


@app.get(
    "/api/v1/statuses/{id}/favourited_by",
    response_model=Account,
    responses={"404": {"model": Error}},
)
def get_api_v1_statuses_id_favourited_by(id: str) -> Union[Account, Error]:
    pass


@app.post(
    "/api/v1/statuses/{id}/mute",
    response_model=Status,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def post_api_v1_statuses_id_mute(id: str) -> Union[Status, Error]:
    pass


@app.post(
    "/api/v1/statuses/{id}/pin",
    response_model=Status,
    responses={
        "401": {"model": Error},
        "404": {"model": Error},
        "422": {"model": Error},
    },
)
def post_api_v1_statuses_id_pin(id: str) -> Union[Status, Error]:
    pass


@app.post(
    "/api/v1/statuses/{id}/reblog",
    response_model=Status,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def post_api_v1_statuses_id_reblog(id: str, body: ApiV1StatusesIdReblogPostRequest = None) -> Union[Status, Error]:
    pass


@app.get(
    "/api/v1/statuses/{id}/reblogged_by",
    response_model=Account,
    responses={"404": {"model": Error}},
)
def get_api_v1_statuses_id_reblogged_by(id: str) -> Union[Account, Error]:
    pass


@app.post(
    "/api/v1/statuses/{id}/unbookmark",
    response_model=Status,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def post_api_v1_statuses_id_unbookmark(id: str) -> Union[Status, Error]:
    pass


@app.post(
    "/api/v1/statuses/{id}/unfavourite",
    response_model=Status,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def post_api_v1_statuses_id_unfavourite(id: str) -> Union[Status, Error]:
    pass


@app.post(
    "/api/v1/statuses/{id}/unmute",
    response_model=Status,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def post_api_v1_statuses_id_unmute(id: str) -> Union[Status, Error]:
    pass


@app.post(
    "/api/v1/statuses/{id}/unpin",
    response_model=Status,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def post_api_v1_statuses_id_unpin(id: str) -> Union[Status, Error]:
    pass


@app.post(
    "/api/v1/statuses/{id}/unreblog",
    response_model=Status,
    responses={"401": {"model": Error}, "404": {"model": Error}},
)
def post_api_v1_statuses_id_unreblog(id: str) -> Union[Status, Error]:
    pass


@app.get("/api/v1/suggestions", response_model=Account, responses={"401": {"model": Error}})
def get_api_v1_suggestions(limit: Optional[int] = 40) -> Union[Account, Error]:
    pass


@app.delete(
    "/api/v1/suggestions/{id}",
    response_model=ApiV1SuggestionsIdDeleteResponse,
    responses={"401": {"model": Error}},
)
def delete_api_v1_suggestions_id(
    id: str,
) -> Union[ApiV1SuggestionsIdDeleteResponse, Error]:
    pass


@app.get(
    "/api/v1/timelines/home",
    response_model=List[Status],
    responses={"401": {"model": Error}},
)
def get_api_v1_timelines_home(
    local: Optional[bool] = False,
    limit: Optional[int] = 20,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
    min_id: Optional[str] = None,
) -> Union[List[Status], Error]:
    return []


@app.get(
    "/api/v1/timelines/list/{list_id}",
    response_model=List[Status],
    responses={"401": {"model": Error}},
)
def get_api_v1_timelines_list_list_id(
    list_id: str,
    limit: Optional[int] = 20,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
    min_id: Optional[str] = None,
    current_user: Account = Depends(get_current_user),
) -> Union[List[Status], Error]:
    if not current_user:
        return Error(error="Unauthorized")
    return get_timeline(current_user.acct, limit=limit)


@app.get("/api/v1/timelines/public", response_model=List[Status])
def get_api_v1_timelines_public(
    local: Optional[bool] = False,
    remote: Optional[bool] = False,
    only_media: Optional[bool] = False,
    limit: Optional[int] = 20,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
    min_id: Optional[str] = None,
) -> List[Status]:
    return []


@app.get("/api/v1/timelines/tag/{hashtag}", response_model=List[Status])
def get_api_v1_timelines_tag_hashtag(
    hashtag: str,
    local: Optional[bool] = False,
    remote: Optional[bool] = False,
    only_media: Optional[bool] = False,
    limit: Optional[int] = 20,
    max_id: Optional[str] = None,
    since_id: Optional[str] = None,
    min_id: Optional[str] = None,
) -> List[Status]:
    pass


@app.get("/api/v1/trends", response_model=List[Tag])
def get_api_v1_trends(limit: Optional[int] = 10) -> List[Tag]:
    return []


@app.get(
    "/api/v2/search",
    response_model=ApiV2SearchGetResponse,
    responses={"401": {"model": Error}},
)
def get_api_v2_search(
    q: str,
    limit: Optional[int] = 20,
    resolve: Optional[str] = None,
    following: Optional[bool] = None,
    account_id: Optional[str] = None,
    max_id: Optional[str] = None,
    min_id: Optional[str] = None,
    type: Optional[Type4] = None,
    exclude_unreviewed: Optional[bool] = None,
    offset: Optional[int] = None,
) -> Union[ApiV2SearchGetResponse, Error]:
    pass


@app.get("/oauth/authorize", response_model=None, responses={"400": {"model": Error}})
def get_oauth_authorize(
    response_type: str,
    client_id: str = ...,
    redirect_uri: str = ...,
    scope: Optional[str] = None,
    force_login: Optional[bool] = None,
    current_user: Account = Depends(get_current_user),
) -> Union[None, Error]:
    if not current_user:
        return RedirectResponse(url="/login")
    print(response_type, client_id, redirect_uri, scope)
    code = "".join((secrets.choice(string.ascii_letters) for i in range(20)))
    save_oauth_client_data(client_id, client_secret="", scope=scope, acct=current_user.acct, code=code)
    return HTMLResponse(f'<a href="{redirect_uri}?code={code}">Authorize</a>')


@app.post("/oauth/revoke", response_model=None, responses={"403": {"model": Error}})
def post_oauth_revoke() -> Union[None, Error]:
    pass


@app.post(
    "/oauth/token",
    response_model=OauthTokenPostResponse,
    responses={"400": {"model": Error}, "401": {"model": Error}},
)
def post_oauth_token(req: OauthTokenPostRequest) -> Union[OauthTokenPostResponse, Error]:
    print(req)
    acct = check_client_id_code(req.client_id, req.code)
    print(acct)
    if acct:
        access_token = create_access_token({"acct": acct, "client_id": req.client_id})
        r = OauthTokenPostResponse(
            access_token=access_token,
            token_type="bearer",
            scope="read write follow",
            created_at=int(time.time()),
        )
        print(r)
        return r
    return Error(error="invalid_client", error_description="Invalid client")


from fastapi import WebSocket


@app.websocket("/api/v1/streaming")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        await websocket.send_text(f"Message text was: {data}")


@app.post("/token", response_model=Token)
async def login(form_data: OAuth2PasswordRequestForm = Depends()):
    hashed_password = get_account_password(form_data.username)
    if not hashed_password:
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    if not verify_password(form_data.password, hashed_password):
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    return {"access_token": create_access_token({"acct": form_data.username}), "token_type": "bearer"}


from fastapi.templating import Jinja2Templates

templates = Jinja2Templates(directory="templates/")


@app.get("/login")
def login_get(request: Request):
    return templates.TemplateResponse("login.html", context={"request": request})


@app.post("/login")
def login_post(request: Request, response: Response, form_data: OAuth2PasswordRequestForm = Depends()):
    hashed_password = get_account_password(form_data.username)
    if not hashed_password:
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    if not verify_password(form_data.password, hashed_password):
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    access_token = create_access_token({"acct": form_data.username})
    resp = templates.TemplateResponse("login.html", context={"request": request, "message": "Logged in successfully!"})
    resp.set_cookie(key="access_token", value=f"Bearer {access_token}", httponly=True)
    return resp


@app.get("/create_account")
def create_account_get(request: Request):
    return templates.TemplateResponse("create_account.html", context={"request": request})


@app.post("/create_account")
def create_account_post(request: Request, response: Response, form_data: CreateAccountForm = Depends()):
    hashed_password = get_account_password(form_data.username)
    if hashed_password:
        raise HTTPException(status_code=400, detail="Username already exists")
    hashed_password = get_password_hash(form_data.password)
    insert_account(
        Account(
            id=uuid.uuid1().int >> 64,
            username=form_data.username,
            acct=form_data.username,
            display_name=form_data.username,
            note="",
            avatar="",
            avatar_static="",
            header="",
            header_static="",
            locked=False,
            emojis=[],
            discoverable=True,
            created_at=datetime.datetime.utcnow().replace(tzinfo=pytz.utc),
            followers_count=0,
            following_count=0,
            statuses_count=0,
            fields=[],
            bot=False,
            suspended=False,
            url=f"https://folx.co/@{form_data.username}",
        ),
        password=hashed_password,
    )
    access_token = create_access_token({"acct": form_data.username})
    resp = templates.TemplateResponse(
        "create_account.html", context={"request": request, "message": "Account created successfully!"}
    )
    resp.set_cookie(key="access_token", value=f"Bearer {access_token}", httponly=True)
    return resp


@app.get("/.well-known/webfinger")
def webfinger(request: Request):
    resource = request.query_params.get("resource")
    if resource:
        acct = resource.split(":")[1]
        acct = acct.split("@")[0]
        account = get_account(acct)
        if account:
            return {
                "subject": resource,
                "links": [
                    {
                        "rel": "self",
                        "type": "application/activity+json",
                        "href": f"https://folx.co/users/{acct}",
                    }
                ],
            }
    return Response(status_code=400)
