# generated by fastapi-codegen:
#   filename:  api-specification.yml
#   timestamp: 2022-11-18T14:46:49+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union
from fastapi import Form

from pydantic import BaseModel, Field, SecretStr


class Activity(BaseModel):
    week: Optional[str] = Field(None, description="Midnight at the first day of the week.  (UNIX Timestamp).")
    statuses: Optional[str] = Field(
        None,
        description="Statuses created since the week began, String (cast from an integer).",
    )
    logins: Optional[str] = Field(
        None,
        description="User logins since the week began, String (cast from an integer).",
    )
    registrations: Optional[str] = Field(
        None,
        description="User registrations since the week began, String (cast from an integer).",
    )


class Announcement(BaseModel):
    id: str = Field(
        ...,
        description="The announcement id. Cast from an integer, but not guaranteed to be a number.",
    )
    text: str = Field(..., description="The content of the announcement.")
    published: bool = Field(..., description="Whether the announcement is currently active.")
    all_day: bool = Field(..., description="Whether the announcement has a start/end time.")
    created_at: str = Field(..., description="When the announcement was created.")
    updated_at: str = Field(..., description="When the announcement was last updated. ISO 8601 Datetime.")
    read: bool = Field(..., description="Whether the announcement has been read by the user.")
    scheduled_at: Optional[str] = Field(
        None,
        description="When the future announcement was scheduled. ISO 8601 Datetime.",
    )
    starts_at: Optional[str] = Field(None, description="When the future announcement will start. ISO 8601 Datetime.")
    ends_at: Optional[str] = Field(None, description="When the future announcement will end. ISO 8601 Datetime.")


class AnnouncementReaction(BaseModel):
    name: Optional[str] = Field(
        None,
        description="The emoji used for the reaction. Either a unicode emoji, or a custom emoji's shortcode.",
    )
    count: Optional[int] = Field(None, description="The total number of users who have added this reaction.")
    me: Optional[bool] = Field(
        None,
        description="Whether the authorized user has added this reaction to the announcement.",
    )
    url: Optional[str] = Field(None, description="A link to the custom emoji (URL).")
    static_url: Optional[str] = Field(None, description="A link to a non-animated version of the custom emoji (URL).")


class Application(BaseModel):
    name: str = Field(..., description="The name of your application.")
    website: Optional[str] = Field(None, description="The website associated with your application. Must be URL.")
    vapid_key: Optional[str] = Field(
        None,
        description="Used for Push Streaming API. Returned with [POST /api/v1/apps](https://docs.joinmastodon.org/methods/apps/#create-an-application). Equivalent to [PushSubscription#server_key](https://docs.joinmastodon.org/entities/pushsubscription/#server_key)",
    )
    client_id: Optional[str] = Field(None, description="Client ID key, to be used for obtaining OAuth tokens")
    client_secret: Optional[str] = Field(None, description="Client secret key, to be used for obtaining OAuth tokens")


class Type(Enum):
    unknown = "unknown"
    image = "image"
    gifv = "gifv"
    video = "video"
    audio = "audio"


class Attachment(BaseModel):
    id: str = Field(
        ...,
        description="The ID of the attachment in the database. Cast from an integer but not guaranteed to be a number",
    )
    type: Type = Field(..., description="The type of the attachment.")
    url: str = Field(..., description="The location of the original full-size attachment.")
    preview_url: str = Field(..., description="The location of a scaled-down preview of the attachment.")
    remote_url: Optional[str] = Field(
        None,
        description="The location of the full-size original attachment on the remote website. String or null if the attachment is local.",
    )
    meta: Optional[Dict[str, Any]] = Field(None, description="Metadata returned by Paperclip.")
    description: Optional[str] = Field(
        None,
        description="Alternate text that describes what is in the media attachment, to be used for the visually impaired or when media attachments do not load.",
    )
    blurhash: Optional[str] = Field(
        None,
        description="A hash computed by the [BlurHash algorithm](https://github.com/woltapp/blurhash), for generating colorful preview thumbnails when media has not been downloaded yet.",
    )
    text_url: Optional[str] = Field(None, description="A shorter URL for the attachment.")


class Type1(Enum):
    link = "link"
    photo = "photo"
    video = "video"
    rich = "rich"


class Card(BaseModel):
    url: str = Field(..., description="Location of linked resource.")
    title: str = Field(..., description="Title of linked resource.")
    description: str = Field(..., description="Description of preview.")
    type: Type1 = Field(..., description="The type of the preview card. String (Enumerable, oneOf).")
    author_name: Optional[str] = Field(None, description="The author of the original resource.")
    author_url: Optional[str] = Field(None, description="A link to the author of the original resource.")
    provider_name: Optional[str] = Field(None, description="The provider of the original resource.")
    provider_url: Optional[str] = Field(None, description="A link to the provider of the original resource.")
    html: Optional[str] = Field(None, description="HTML to be used for generating the preview card.")
    width: Optional[int] = Field(None, description="Width of preview, in pixels.")
    height: Optional[int] = Field(None, description="Height of preview, in pixels.")
    image: Optional[str] = Field(None, description="Preview thumbnail (URL).")
    blurhash: Optional[str] = Field(
        None,
        description="A hash computed by the [BlurHash algorithm](https://github.com/woltapp/blurhash), for generating colorful preview thumbnails when media has not been downloaded yet.",
    )


class Emoji(BaseModel):
    shortcode: str = Field(..., description="The name of the custom emoji.")
    url: str = Field(..., description="A link to the custom emoji. The format is URL.")
    static_url: str = Field(
        ...,
        description="A link to a static copy of the custom emoji. The format is URL.",
    )
    visible_in_picker: bool = Field(
        ...,
        description="Whether this Emoji should be visible in the picker or unlisted.",
    )
    category: Optional[str] = Field(None, description="Used for sorting custom emoji in the picker.")


class Error(BaseModel):
    error: str
    error_description: Optional[str] = None


class FeaturedTag(BaseModel):
    id: Optional[str] = Field(
        None,
        description="The internal ID of the featured tag in the database. Cast from integer but not guaranteed to be a number",
    )
    name: Optional[str] = Field(None, description="The name of the hashtag being featured.")
    url: Optional[str] = Field(None, description="A link to all statuses by a user that contain this hashtag.")
    statuses_count: Optional[int] = Field(None, description="The number of authored statuses containing this hashtag.")
    last_status_at: Optional[datetime] = Field(
        None,
        description="The timestamp of the last authored status containing this hashtag. ISO 8601 Datetime.",
    )


class FieldModel(BaseModel):
    name: Optional[str] = Field(None, description="The key of a given field's key-value pair.")
    value: Optional[str] = Field(None, description="The value associated with the `name` key.")
    verified_at: Optional[datetime] = Field(
        None,
        description='Timestamp of when the server verified a URL value for a rel="me‚Äù link. If `value` is a verified URL. Otherwise, null',
    )


class ContextEnum(Enum):
    home = "home"
    notifications = "notifications"
    public = "public"
    thread = "thread"


class Filter(BaseModel):
    id: Optional[str] = Field(
        None,
        description="The ID of the filter in the database. Cast from an integer, but not guaranteed to be a number.",
    )
    phrase: Optional[str] = Field(None, description="The text to be filtered.")
    context: Optional[List[ContextEnum]] = Field(
        None, description="The contexts in which the filter should be applied."
    )
    expires_at: Optional[str] = Field(
        None,
        description="When the filter should no longer be applied. ISO 8601 Datetime, or null if the filter does not expire",
    )
    irreversible: Optional[bool] = Field(
        None,
        description="Should matching entities in home and notifications be dropped by the server?",
    )
    whole_word: Optional[bool] = Field(None, description="Should the filter consider word boundaries?")


class History(BaseModel):
    day: str = Field(..., description="UNIX timestamp on midnight of the given day.")
    uses: str = Field(
        ...,
        description="the counted usage of the tag within that day. Cast from an integer.",
    )
    accounts: str = Field(
        ...,
        description="the total of accounts using the tag within that day. Cast from an integer.",
    )


class IdentityProof(BaseModel):
    provider: Optional[str] = Field(None, description="The name of the identity provider.")
    provider_username: Optional[str] = Field(
        None,
        description="The account owner's username on the identity provider's service.",
    )
    profile_url: Optional[str] = Field(None, description="The account owner's profile URL on the identity provider.")
    proof_url: Optional[str] = Field(
        None,
        description="A link to a statement of identity proof, hosted by the identity provider.",
    )
    updated_at: Optional[str] = Field(None, description="When the identity proof was last updated. ISO 8601 Datetime.")


class RepliesPolicy(Enum):
    followed = "followed"
    list = "list"
    none = "none"


class ListModel(BaseModel):
    id: str = Field(
        ...,
        description="The internal database ID of the list. Cast from an integer, but not guaranteed to be a number.",
    )
    title: str = Field(..., description="The user-defined title of the list.")
    replies_policy: RepliesPolicy = Field(..., description="The user-defined title of the list.")


class Marker(BaseModel):
    home: Optional[Dict[str, Any]] = Field(
        None, description="Information about the user's position in the home timeline."
    )
    notifications: Optional[Dict[str, Any]] = Field(
        None,
        description="Information about the user's position in their notifications.",
    )
    last_read_id: Optional[str] = Field(
        None,
        description="The ID of the most recently viewed entity. Cast from integer but not guaranteed to be a number",
    )
    updated_at: Optional[datetime] = Field(
        None, description="The timestamp of when the marker was set. ISO 8601 Datetime."
    )
    version: Optional[int] = Field(None, description="Used for locking to prevent write conflicts.")


class Mention(BaseModel):
    id: str = Field(
        ...,
        description="The account id of the mentioned user. Cast from an integer, but not guaranteed to be a number",
    )
    username: str = Field(..., description="The username of the mentioned user.")
    acct: str = Field(
        ...,
        description="The webfinger acct URI of the mentioned user. Equivalent to `username` for local users, or `username@domain` for remote users.",
    )
    url: str = Field(..., description="The location of the mentioned user's profile.")


class Type2(Enum):
    follow = "follow"
    follow_request = "follow_request"
    mention = "mention"
    reblog = "reblog"
    favourite = "favourite"
    poll = "poll"
    status = "status"


class Poll(BaseModel):
    id: Optional[str] = Field(
        None,
        description="The ID of the poll in the database. Cast from an integer, but not guaranteed to be a number.",
    )
    expires_at: Optional[datetime] = Field(
        None,
        description="When the poll ends. ISO 8601 Datetime, or null if the poll does not end.",
    )
    expired: Optional[bool] = Field(None, description="Is the poll currently expired?")
    multiple: Optional[bool] = Field(None, description="Does the poll allow multiple-choice answers?")
    votes_count: Optional[int] = Field(None, description="How many votes have been received.")
    voters_count: Optional[int] = Field(
        None,
        description="How many unique accounts have voted on a multiple-choice poll. Number, or null if `multiple` is false.",
    )
    voted: Optional[bool] = Field(
        None,
        description="When called with a user token, has the authorized user voted? Boolean, or null if no current user",
    )
    own_votes: Optional[List[int]] = Field(
        None,
        description="When called with a user token, which options has the authorized user chosen? Contains an array of index values for `options`. Array of Number, or null if no current user",
    )
    options: Optional[List] = Field(None, description="Possible answers for the poll.")
    emojis: Optional[List[Emoji]] = Field(None, description="Custom emoji to be used for rendering poll options.")


class PostingDefaultVisibility(Enum):
    public = "public"
    unlisted = "unlisted"
    private = "private"
    direct = "direct"


class ReadingExpandMedia(Enum):
    default = "default"
    show_all = "show_all"
    hide_all = "hide_all"


class Preferences(BaseModel):
    posting_default_visibility: Optional[PostingDefaultVisibility] = Field(
        None,
        alias="posting:default:visibility",
        description="Default visibility for new posts. Equivalent to [Source#privacy](https://docs.joinmastodon.org/entities/source/#privacy).",
    )
    posting_default_sensitive: Optional[bool] = Field(
        None,
        alias="posting:default:sensitive",
        description="Default sensitivity flag for new posts. Equivalent to [Source#sensitive](https://docs.joinmastodon.org/entities/source/#sensitive).",
    )
    posting_default_language: Optional[str] = Field(
        None,
        alias="posting:default:language",
        description="Default language for new posts. Equivalent to [Source#language](https://docs.joinmastodon.org/entities/source/#language). ISO 639-1 language two-letter code, or null",
    )
    reading_expand_media: Optional[ReadingExpandMedia] = Field(
        None,
        alias="reading:expand:media",
        description="Whether media attachments should be automatically displayed or blurred/hidden.",
    )
    reading_expand_spoilers: Optional[bool] = Field(
        None,
        alias="reading:expand:spoilers",
        description="Whether CWs should be expanded by default.",
    )


class PushSubscription(BaseModel):
    id: str = Field(
        ...,
        description="The ID of the push subscription in the database. Cast from an integer, but not guaranteed to be a number.",
    )
    endpoint: str = Field(..., description="Where push alerts will be sent to.")
    server_key: str = Field(..., description="The streaming server's VAPID key.")
    alerts: Dict[str, Any] = Field(..., description="Which alerts should be delivered to the `endpoint`.")


class Relationship(BaseModel):
    id: str = Field(
        ...,
        description="The account id. Cast from an integer, but not guaranteed to be a number.",
    )
    following: bool = Field(..., description="Are you following this user?")
    requested: bool = Field(..., description="Do you have a pending follow request for this user?")
    endorsed: bool = Field(..., description="Are you featuring this user on your profile?")
    followed_by: bool = Field(..., description="Are you followed by this user?")
    muting: bool = Field(..., description="Are you muting this user?")
    muting_notifications: bool = Field(..., description="Are you muting notifications from this user?")
    showing_reblogs: bool = Field(..., description="Are you receiving this user's boosts in your home timeline?")
    notifying: bool = Field(..., description="Have you enabled notifications for this user?")
    blocking: bool = Field(..., description="Are you blocking this user?")
    domain_blocking: bool = Field(..., description="Are you blocking this user's domain?")
    blocked_by: bool = Field(..., description="Is this user blocking you?")
    note: str = Field(..., description="This user's profile bio")


class Category(Enum):
    other = "other"
    spam = "spam"
    violation = "violation"


class StatusParams(BaseModel):
    text: Optional[str] = Field(None, description="text")
    in_reply_to_id: Optional[str] = Field(None, description="in_reply_to_id")
    media_ids: Optional[List[str]] = Field(None, description="media_ids")
    sensitive: Optional[bool] = Field(None, description="sensitive")
    spoiler_text: Optional[str] = Field(None, description="spoiler_text")
    visibility: Optional[str] = Field(None, description="visibility")
    scheduled_at: Optional[datetime] = Field(None, description="scheduled_at")
    application_id: Optional[str] = Field(None, description="application_id")


class Privacy(Enum):
    public = "public"
    unlisted = "unlisted"
    private = "private"
    direct = "direct"


class Source(BaseModel):
    note: Optional[str] = Field(None, description="Profile bio")
    fields: Optional[List[FieldModel]] = Field(None, description="Metadata about the account.")
    privacy: Optional[Privacy] = Field(None, description="The default post privacy to be used for new statuses.")
    sensitive: Optional[bool] = Field(None, description="Whether new statuses should be marked sensitive by default.")
    language: Optional[str] = Field(
        None,
        description="The default posting language for new statuses, ISO 639-1 language two-letter code.",
    )
    follow_requests_count: Optional[int] = Field(None, description="The number of pending follow requests")


class Visibility(Enum):
    public = "public"
    unlisted = "unlisted"
    private = "private"
    direct = "direct"


class Tag(BaseModel):
    name: str = Field(..., description="The value of the hashtag after the `#` sign.")
    url: str = Field(..., description="A link to the hashtag on the instance.")
    history: Optional[List[History]] = Field(None, description="Usage statistics for given days.")


class Token(BaseModel):
    access_token: Optional[str] = Field(None, description="An OAuth token to be used for authorization.")
    token_type: Optional[str] = Field(None, description="The OAuth token type. Mastodon uses `Bearer` tokens.")
    scope: Optional[str] = Field(None, description="The OAuth scopes granted by this token, space-separated.")
    created_at: Optional[int] = Field(None, description="When the token was generated. UNIX Timestamp.")


class ApiV1AppsPostRequest(BaseModel):
    client_name: Optional[str] = Field(None, description="A name for your application")
    redirect_uris: Optional[str] = Field(
        None,
        description="Where the user should be redirected after authorization. To display the authorization code to the user instead of redirecting to a web page, use urn:ietf:wg:oauth:2.0:oob in this parameter.",
    )
    scopes: Optional[str] = Field(
        None,
        description="Space separated list of scopes. If none is provided, defaults to read.",
    )
    website: Optional[str] = Field(None, description="A URL to the homepage of your app")


class ApiV1AppsPostResponse(BaseModel):
    id: Optional[str] = None
    name: Optional[str] = None
    website: Optional[str] = None
    redirect_uri: Optional[str] = None
    client_id: Optional[str] = None
    client_secret: Optional[str] = None
    vapid_key: Optional[str] = None


class OauthTokenPostRequest(BaseModel):
    grant_type: str = Field(
        ...,
        description="Set equal to authorization_code if code is provided in order to gain user-level access. Otherwise, set equal to client_credentials to obtain app-level access only.",
    )
    client_id: str = Field(..., description="Client ID, obtained during app registration")
    client_secret: str = Field(..., description="Client secret, obtained during app registration")
    redirect_uri: str = Field(
        ...,
        description="Set a URI to redirect the user to. If this parameter is set to urn:ietf:wg:oauth:2.0:oob then the token will be shown instead. Must match one of the redirect URIs declared during app registration.",
    )
    scopes: Optional[str] = Field(
        None,
        description="List of requested OAuth scopes, separated by spaces. Must be a subset of scopes declared during app registration. If not provided, defaults to read.",
    )
    code: Optional[str] = Field(None, description="A user authorization code, obtained via /oauth/authorize")


class OauthTokenPostResponse(BaseModel):
    access_token: Optional[str] = Field(None, example="ZA-Yj3aBD8U8Cm7lKUp-lm9O9BmDgdhHzDeqsY8tlL0")
    token_type: Optional[str] = Field(None, example="Bearer")
    scope: Optional[str] = Field(None, example="read write follow push")
    created_at: Optional[int] = Field(None, description="UNIX timestamp", example=1573979017)


class OauthRevokePostRequest(BaseModel):
    client_id: str = Field(..., description="Client ID, obtained during app registration")
    client_secret: str = Field(..., description="Client secret, obtained during app registration")
    token: str = Field(..., description="The previously obtained token, to be invalidated")


class ApiV1AccountsPostRequest(BaseModel):
    username: str = Field(..., description="The desired username for the account")
    email: str = Field(..., description="The email address to be used for login")
    password: SecretStr = Field(..., description="The password to be used for login")
    agreement: bool = Field(
        ...,
        description="Whether the user agrees to the local rules, terms, and policies. These should be presented to the user in order to allow them to consent before setting this parameter to TRUE.",
    )
    locale: str = Field(..., description="The language of the confirmation email that will be sent")
    reason: Optional[str] = Field(
        None,
        description="Text that will be reviewed by moderators if registrations require manual approval.",
    )


class Source1(BaseModel):
    privacy: Optional[str] = Field(None, description="Default post privacy for authored statuses.")
    sensitive: Optional[bool] = Field(None, description="Whether to mark authored statuses as sensitive by default.")
    language: Optional[str] = Field(None, description="Default language to use for authored statuses. (ISO 6391)")


class ApiV1AccountsUpdateCredentialsPatchRequest(BaseModel):
    discoverable: Optional[str] = Field(
        None,
        description="Whether the account should be shown in the profile directory.",
    )
    bot: Optional[bool] = Field(None, description="Whether the account has a bot flag.")
    display_name: Optional[str] = Field(None, description="The display name to use for the profile.")
    note: Optional[str] = Field(None, description="The account bio.")
    avatar: Optional[str] = Field(None, description="Avatar image encoded using multipart/form-data")
    header: Optional[str] = Field(None, description="Header image encoded using multipart/form-data")
    locked: Optional[bool] = Field(None, description="Whether manual approval of follow requests is required.")
    source: Optional[Source1] = None
    fields_attributes: Optional[Dict[str, Any]] = Field(
        None,
        description="Profile metadata `name` and `value`. (By default, max 4 fields and 255 characters per property/value)",
    )


class ApiV1AccountsIdFollowPostRequest(BaseModel):
    reblogs: Optional[bool] = Field(
        True,
        description="Receive this account's reblogs in home timeline? Defaults to true.",
    )
    notify: Optional[bool] = Field(
        False,
        description="Receive notifications when this account posts a status? Defaults to false.",
    )


class ApiV1AccountsIdMutePostRequest(BaseModel):
    notifications: Optional[bool] = Field(
        True,
        description="Mute notifications in addition to statuses? Defaults to true.",
    )
    duration: Optional[int] = Field(
        0,
        description="How long the mute should last, in seconds. Defaults to 0 (indefinite).",
    )


class ApiV1AccountsIdNotePostRequest(BaseModel):
    comment: Optional[str] = Field(
        None,
        description="The comment to be set on that user. Provide an empty string or leave out this parameter to clear the currently set note.",
    )


class ApiV1DomainBlocksPostRequest(BaseModel):
    domain: str = Field(..., description="Domain to block.")


class ApiV1DomainBlocksPostResponse(BaseModel):
    pass


class ApiV1DomainBlocksDeleteResponse(BaseModel):
    pass


class ContextEnum1(Enum):
    home = "home"
    notifications = "notifications"
    public = "public"
    thread = "thread"


class ApiV1FiltersPostRequest(BaseModel):
    phrase: str = Field(..., description="Text to be filtered.")
    context: List[ContextEnum1] = Field(
        ...,
        description="Array of enumerable strings `home`, `notifications`, `public`, `thread`. At least one context must be specified.",
    )
    irreversible: Optional[bool] = Field(
        None,
        description="Should the server irreversibly drop matching entities from home and notifications?",
    )
    whole_word: Optional[bool] = Field(None, description="Consider word boundaries?")
    expires_in: Optional[int] = Field(
        None,
        description="Number of seconds from now the filter should expire. Otherwise, null for a filter that doesn't expire.",
    )


class ContextEnum2(Enum):
    home = "home"
    notifications = "notifications"
    public = "public"
    thread = "thread"


class ApiV1FiltersIdPutRequest(BaseModel):
    phrase: str = Field(..., description="Text to be filtered.")
    context: List[ContextEnum2] = Field(
        ...,
        description="Array of enumerable strings `home`, `notifications`, `public`, `thread`. At least one context must be specified.",
    )
    irreversible: Optional[bool] = Field(
        None,
        description="Should the server irreversibly drop matching entities from home and notifications?",
    )
    whole_word: Optional[bool] = Field(None, description="Consider word boundaries?")
    expires_in: Optional[int] = Field(
        None,
        description="Number of seconds from now the filter should expire. Otherwise, null for a filter that doesn't expire.",
    )


class ApiV1ReportsPostRequest(BaseModel):
    account_id: str = Field(..., description="ID of the account to report")
    status_ids: Optional[List[str]] = Field(None, description="Array of Statuses to attach to the report, for context")
    comment: Optional[str] = Field(None, description="Reason for the report (default max 1000 characters)")
    forward: Optional[bool] = Field(
        None,
        description="If the account is remote, should the report be forwarded to the remote admin?",
    )


class ApiV1FeaturedTagsPostRequest(BaseModel):
    name: Optional[str] = None


class ApiV1FeaturedTagsIdDeleteResponse(BaseModel):
    pass


class ApiV1SuggestionsIdDeleteResponse(BaseModel):
    pass


class Visibility1(Enum):
    public = "public"
    unlisted = "unlisted"
    private = "private"
    direct = "direct"


class ApiV1StatusesPostRequest(BaseModel):
    status: Optional[str] = Field(
        None,
        description="Text content of the status. If `media_ids` is provided, this becomes optional. Attaching a `poll` is optional while `status` is provided.",
    )
    media_ids: Optional[List[str]] = Field(
        None,
        description="Array of Attachment ids to be attached as media. If provided, `status` becomes optional, and `poll` cannot be used.",
    )
    poll: Optional[List[Dict[str, Any]]] = None
    in_reply_to_id: Optional[str] = Field(None, description="ID of the status being replied to, if status is a reply")
    sensitive: Optional[bool] = Field(None, description="Mark status and attached media as sensitive?")
    spoiler_text: Optional[str] = Field(
        None,
        description="Text to be shown as a warning or subject before the actual content. Statuses are generally collapsed behind this field.",
    )
    visibility: Optional[Visibility1] = Field(
        None,
        description="Visibility of the posted status. Enumerable oneOf public, unlisted, private, direct.",
    )
    scheduled_at: Optional[str] = Field(
        None,
        description="ISO 8601 Datetime at which to schedule a status. Providing this paramter will cause ScheduledStatus to be returned instead of Status. Must be at least 5 minutes in the future.",
    )
    language: Optional[str] = Field(None, description="ISO 639 language code for this status.")


class ApiV1StatusesIdReblogPostRequest(BaseModel):
    visibility: Optional[str] = Field(
        None,
        description="any visibility except limited or direct (i.e. public, unlisted, private). Defaults to public. Currently unused in UI.",
    )


class ApiV1MediaPostRequest(BaseModel):
    file: bytes = Field(..., description="The file to be attached, using multipart form data.")
    thumbnail: Optional[bytes] = Field(
        None,
        description="The custom thumbnail of the media to be attached, using multipart form data.",
    )
    description: Optional[str] = Field(
        None,
        description="A plain-text description of the media, for accessibility purposes.",
    )
    focus: Optional[str] = Field(
        None,
        description="Two floating points (x,y), comma-delimited, ranging from -1.0 to 1.0 (see ‚ÄúFocal points‚Äù below)",
    )


class ApiV1MediaIdPostRequest(BaseModel):
    file: bytes = Field(..., description="The file to be attached, using multipart form data.")
    thumbnail: Optional[bytes] = Field(
        None,
        description="The custom thumbnail of the media to be attached, using multipart form data.",
    )
    description: Optional[str] = Field(
        None,
        description="A plain-text description of the media, for accessibility purposes.",
    )
    focus: Optional[str] = Field(
        None,
        description="Two floating points (x,y), comma-delimited, ranging from -1.0 to 1.0 (see ‚ÄúFocal points‚Äù below)",
    )


class ApiV1PollsIdPostRequest(BaseModel):
    choices: List[str]


class ApiV1ScheduledStatusesIdPutRequest(BaseModel):
    scheduled_at: Optional[datetime] = Field(
        None,
        description="ISO 8601 Datetime at which the status will be published. Must be at least 5 minutes into the future.",
    )


class ApiV1ScheduledStatusesIdDeleteResponse(BaseModel):
    pass


class ApiV1ConversationsIdDeleteResponse(BaseModel):
    pass


class RepliesPolicy1(Enum):
    followed = "followed"
    list = "list"
    none = "none"


class ApiV1ListsPostRequest(BaseModel):
    title: str = Field(..., description="The title of the list to be created.")
    replies_policy: Optional[RepliesPolicy1] = Field(
        "list", description="Enumerable oneOf followed list none. Defaults to list."
    )


class RepliesPolicy2(Enum):
    followed = "followed"
    list = "list"
    none = "none"


class ApiV1ListsPutRequest(BaseModel):
    title: Optional[str] = Field(None, description="The title of the list to be created.")
    replies_policy: Optional[RepliesPolicy2] = Field(
        "list", description="Enumerable oneOf followed list none. Defaults to list."
    )


class ApiV1ListsDeleteResponse(BaseModel):
    pass


class ApiV1ListsIdAccountsPostRequest(BaseModel):
    account_ids: List[str] = Field(..., description="Array of account IDs to add to the list.")


class ApiV1ListsIdAccountsPostResponse(BaseModel):
    pass


class ApiV1ListsIdAccountsDeleteResponse(BaseModel):
    pass


class ApiV1MarkersGetResponse(BaseModel):
    pass


class ApiV1MarkersPostRequest(BaseModel):
    pass


class ApiV1MarkersPostResponse(BaseModel):
    pass


class ApiV1NotificationsClearPostResponse(BaseModel):
    pass


class ApiV1PushSubscriptionPostRequest(BaseModel):
    subscription: str
    data: str


class ApiV1PushSubscriptionPutRequest(BaseModel):
    data: str


class ApiV1PushSubscriptionDeleteResponse(BaseModel):
    pass


class Type3(Enum):
    accounts = "accounts"
    hashtags = "hashtags"
    statuses = "statuses"


class Type4(Enum):
    accounts = "accounts"
    hashtags = "hashtags"
    statuses = "statuses"


class Order(Enum):
    active = "active"
    new = "new"


class Order1(Enum):
    active = "active"
    new = "new"


class Type5(Enum):
    none = "none"
    disable = "disable"
    silence = "silence"
    suspend = "suspend"


class ApiV1AdminAccountsIdActionPostRequest(BaseModel):
    type: Optional[Type5] = Field(
        None,
        description="Type of action to be taken. Enumerable oneOf: none disable silence suspend",
    )
    report_id: Optional[str] = Field(
        None,
        description="ID of an associated report that caused this action to be taken",
    )
    warning_preset_id: Optional[str] = Field(None, description="ID of a preset warning")
    text: Optional[str] = Field(
        None,
        description="Additional text for clarification of why this action was taken",
    )
    send_email_notification: Optional[bool] = Field(
        None,
        description="Whether an email should be sent to the user with the above information.",
    )


class ApiV1AnnouncementsIdDismissPostResponse(BaseModel):
    pass


class ApiV1AnnouncementsIdReactionsNamePutResponse(BaseModel):
    pass


class ApiV1AnnouncementsIdReactionsNameDeleteResponse(BaseModel):
    pass


class Account(BaseModel):
    id: Optional[str] = Field(None, description="The account id `header`.")
    username: Optional[str] = Field(None, description="The username of the account, not including domain.")
    acct: Optional[str] = Field(
        None,
        description="The Webfinger account URI. Equal to `username` for local users, or `username@domain` for",
    )
    url: Optional[str] = Field(None, description="The location of the user's profile page. (HTTPS URL)")
    display_name: Optional[str] = Field(None, description="The profile's display name.")
    note: Optional[str] = Field(None, description="The profile's bio / description.")
    avatar: Optional[str] = Field(
        None,
        description="An image icon that is shown next to statuses and in the profile. The format is URL.",
    )
    avatar_static: Optional[str] = Field(
        None,
        description="A static version of the avatar. Equal to `avatar` if its value is a static image; different if `avatar` is an animated GIF. The format is URL.",
    )
    header: Optional[str] = Field(
        None,
        description="An image banner that is shown above the profile and in profile cards. The format is URL.",
    )
    header_static: Optional[str] = Field(
        None,
        description="A static version of the header. Equal to `header` if its value is a static image; different if `header` is an animated GIF. The format is URL.",
    )
    locked: Optional[bool] = Field(None, description="Whether the account manually approves follow requests.")
    emojis: Optional[List[Emoji]] = Field(
        None,
        description="Custom emoji entities to be used when rendering the profile. If none, an empty array will be returned.",
    )
    discoverable: Optional[bool] = Field(
        None,
        description="Whether the account has opted into discovery features such as the profile directory.",
    )
    created_at: Optional[datetime] = Field(None, description="When the account was created.")
    last_status_at: Optional[datetime] = Field(None, description="When the most recent status was posted.")
    statuses_count: Optional[int] = Field(None, description="How many statuses are attached to this account.")
    followers_count: Optional[int] = Field(None, description="The reported followers of this profile.")
    following_count: Optional[int] = Field(None, description="The reported follows of this profile.")
    moved: Optional[Account] = None
    fields: Optional[List[FieldModel]] = Field(
        None,
        description="Additional metadata attached to a profile as name-value pairs.",
    )
    bot: Optional[bool] = Field(
        None,
        description="A presentational flag. Indicates that the account may perform automated actions, may not be monitored, or identifies as a robot.",
    )
    source: Optional[Source] = None
    suspended: Optional[bool] = Field(None, description="An extra entity returned when an account is suspended.")
    mute_expires_at: Optional[datetime] = Field(
        None,
        description="When a timed mute will expire, if applicable. ISO 8601 Datetime.",
    )


class AdminAccount(BaseModel):
    id: Optional[str] = Field(
        None,
        description="The ID of the account in the database. Cast from an integer, but not guaranteed to be a number.",
    )
    username: Optional[str] = Field(None, description="The username of the account.")
    created_at: Optional[datetime] = Field(None, description="When the account was first discovered.")
    email: Optional[str] = Field(None, description="The email address associated with the account.")
    ip: Optional[str] = Field(None, description="The IP address last used to login to this account.")
    locale: Optional[str] = Field(
        None,
        description="The locale of the account. ISO 639 Part 1 two-letter language code.",
    )
    invite_request: Optional[str] = Field(None, description="Invite request text ???")
    role: Optional[str] = Field(None, description="The current role of the account. Enumerable oneOf.")
    confirmed: Optional[bool] = Field(None, description="Whether the account has confirmed their email address.")
    approved: Optional[bool] = Field(None, description="Whether the account is currently approved.")
    disabled: Optional[bool] = Field(None, description="Whether the account is currently disabled.")
    silenced: Optional[bool] = Field(None, description="Whether the account is currently silenced.")
    suspended: Optional[bool] = Field(None, description="Whether the account is currently suspended.")
    account: Optional[Account] = None
    created_by_application_id: Optional[str] = Field(
        None,
        description="The ID of the application that created this account. Cast from an integer, but not guaranteed to be a number.",
    )
    invited_by_account_id: Optional[str] = Field(
        None,
        description="The ID of the account that invited this user. Cast from an integer, but not guaranteed to be a number.",
    )


class Instance(BaseModel):
    uri: str = Field(..., description="The domain name of the instance.")
    title: str = Field(..., description="The title of the website.")
    description: str = Field(..., description="Admin-defined description of the Mastodon site.")
    short_description: str = Field(..., description="A shorter description defined by the admin.")
    email: str = Field(..., description="An email that may be contacted for any inquiries.")
    version: str = Field(..., description="The version of Mastodon installed on the instance.")
    languages: List[str] = Field(
        ...,
        description="Primary languages of the website and its staff. ISO 639 Part 1-5 language codes.",
    )
    registrations: bool = Field(..., description="Whether registrations are enabled.")
    approval_required: bool = Field(..., description="Whether registrations require moderator approval.")
    invites_enabled: bool = Field(..., description="Whether invites are enabled.")
    urls: Dict[str, Any] = Field(..., description="URLs of interest for clients apps.")
    stats: Dict[str, Any] = Field(..., description="Statistics about how much information the instance contains.")
    thumbnail: Optional[str] = Field(None, description="Banner image for the website.")
    contact_account: Optional[Account] = None


class Report(BaseModel):
    id: Optional[str] = None
    action_taken: Optional[bool] = None
    action_taken_at: Optional[datetime] = None
    created_at: Optional[datetime] = None
    category: Optional[Category] = None
    comment: Optional[str] = None
    forwarded: Optional[bool] = None
    status_ids: Optional[List[int]] = None
    rule_ids: Optional[List[int]] = None
    target_account: Optional[Account] = None


class ScheduledStatus(BaseModel):
    id: str = Field(
        ...,
        description="ID of the scheduled status in the database. Cast from an integer, but not guaranteed to be a number.",
    )
    scheduled_at: datetime = Field(..., description="ID of the status in the database. ISO 8601 Datetime.")
    params: StatusParams
    media_attachments: List[Attachment] = Field(..., description="Array of attachements")


class Status(BaseModel):
    id: Optional[str] = Field(
        None,
        description="ID of the status in the database. Cast from an integer but not guaranteed to be a number.",
    )
    uri: Optional[str] = Field(None, description="URI of the status used for federation.")
    created_at: Optional[datetime] = Field(None, description="The date when this status was created.")
    account: Optional[Account] = None
    content: Optional[str] = Field(None, description="HTML-encoded status content.")
    visibility: Optional[Visibility] = Field(None, description="Visibility of this status.")
    sensitive: Optional[bool] = Field(None, description="Is this status marked as sensitive content?")
    spoiler_text: Optional[str] = Field(
        None,
        description="Subject or summary line, below which status content is collapsed until expanded.",
    )
    media_attachments: Optional[List[Attachment]] = Field(None, description="Media that is attached to this status.")
    application: Optional[Application] = None
    mentions: Optional[List[Mention]] = Field(None, description="Mentions of users within the status content.")
    tags: Optional[List[Tag]] = Field(None, description="Hashtags used within the status content.")
    emojis: Optional[List[Emoji]] = Field(None, description="Custom emoji to be used when rendering status content.")
    reblogs_count: Optional[int] = Field(None, description="How many boosts this status has received.")
    favourites_count: Optional[int] = Field(None, description="How many favourites this status has received.")
    replies_count: Optional[int] = Field(None, description="How many replies this status has received.")
    url: Optional[str] = Field(None, description="A link to the status's HTML representation.")
    in_reply_to_id: Optional[str] = Field(
        None,
        description="ID of the status being replied. Cast from an integer but not guaranteed to be a number.",
    )
    in_reply_to_account_id: Optional[str] = Field(None, description="ID of the account being replied to.")
    reblog: Optional[Status] = None
    poll: Optional[Poll] = None
    card: Optional[Card] = None
    language: Optional[str] = Field(
        None,
        description="Primary language of this status. ISO 639 Part 1 two-letter language code.",
    )
    text: Optional[str] = Field(
        None,
        description="Plain-text source of a status. Returned instead of `content` when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.",
    )
    favourited: Optional[bool] = Field(None, description="Have you favourited this status?")
    reblogged: Optional[bool] = Field(None, description="Have you boosted this status?")
    muted: Optional[bool] = Field(None, description="Have you muted notifications for this status's conversation?")
    bookmarked: Optional[bool] = Field(None, description="Have you bookmarked this status?")
    pinned: Optional[bool] = Field(
        None,
        description="Have you pinned this status? Only appears if the status is pinnable.",
    )


class ApiV1StatusesPostResponse(BaseModel):
    __root__: Union[Status, ScheduledStatus]


class ApiV2SearchGetResponse(BaseModel):
    accounts: Optional[List[Account]] = None
    statuses: Optional[List[Tag]] = None
    hashtags: Optional[List[Status]] = None


class AdminReport(BaseModel):
    id: Optional[str] = Field(
        None,
        description="The ID of the report in the database. Cast from an integer, but not guaranteed to be a number.",
    )
    action_taken: Optional[str] = Field(None, description="The action taken to resolve this report. Enumerable oneOf.")
    comment: Optional[str] = Field(None, description="An optional reason for reporting.")
    created_at: Optional[datetime] = Field(None, description="The time the report was filed.")
    updated_at: Optional[datetime] = Field(None, description="The time of last action on this report.")
    account: Optional[Account] = None
    target_account: Optional[Account] = None
    assigned_account: Optional[Account] = None
    statuses: Optional[List[Status]] = Field(None, description="Statuses attached to the report, for context.")


class Context(BaseModel):
    ancestors: List[Status] = Field(..., description="Parents in the thread.")
    descendants: List[Status] = Field(..., description="Children in the thread.")


class Conversation(BaseModel):
    id: str = Field(
        ...,
        description="Local database ID of the conversation. Cast from an integer, but not guaranteed to be a number",
    )
    accounts: List[Account] = Field(..., description="Participants in the conversation.")
    unread: bool = Field(..., description="Is the conversation currently marked as unread?")
    last_status: Optional[Status] = None


class Notification(BaseModel):
    id: str = Field(
        ...,
        description="The id of the notification in the database. Cast from an integer, but not guaranteed to be a number.",
    )
    type: Type2 = Field(..., description="The type of event that resulted in the notification.")
    created_at: datetime = Field(..., description="The timestamp of the notification. ISO 8601 Datetime.")
    account: Account
    status: Optional[Status] = None


class Results(BaseModel):
    accounts: List[Account] = Field(..., description="Accounts which match the given query.")
    statuses: List[Status] = Field(..., description="Statuses which match the given query.")
    hashtags: List[Tag] = Field(..., description="Hashtags which match the given query.")


class CreateAccountForm:
    def __init__(
        self,
        username: str = Form(),
        password: str = Form(),
        email: str = Form(),
    ):
        self.username = username
        self.password = password
        self.email = email
